# EvoSuite

## What you will learn in this tutorial

- Generating tests with EvoSuite on the command line
- Running EvoSuite tests on the command line
- Changing EvoSuite properties
- Using EvoSuite together with existing tests

## Prerequisites

> [!NOTE]
> This tutorial is mainly written for unix-like operating systems (e.g., Linux, MacOS). If you are a Windows user, please look out for windows-specific commands/tips.

The first prerequisite for this tutorial is a working Java 8-11 JDK installation and a command-line prompt, with `java` and `javac` on the classpath. To check if you are set up, fire up a terminal and try the following:

`javac -version`

If you have JDK installed, you will see an output similar to the following:

`javac 1.8.0_51`

The specific build version (51 in this case) does not matter. This tutorial should work with Java versions 8 or 11 (e.g., 11.0.23). If you do not have `javac`, then you will need to get a JDK from ([Oracle JDK](https://www.oracle.com/java/technologies/downloads/#java8), [Open JDK](https://openjdk.org/projects/jdk8/), or through [SDKMan](https://sdkman.io/)).

The second prerequisite is [Apache Maven](https://maven.apache.org/). We will just use Maven to compile our example project, so make sure you have version 3.1 or newer installed. To determine which version of Maven you are using, type the following command:

`mvn -version`

This should give you detailed information about the version, e.g.

`Apache Maven 3.9.5 (57804ffe001d7215b5e7bcb531cf83df38f93546)`

Anything greater or equal to 3.1 should be fine. If you don’t have Maven, or have an older version, please install it.

## Obtaining EvoSuite

The EvoSuite homepage is at http://www.evosuite.org/ and the source code is hosted as an open-source project on GitHub at https://github.com/EvoSuite/evosuite/.

In this tutorial, we will use the latest release version [1.2.0](https://github.com/EvoSuite/evosuite/releases). For convenience, the two main jar files are included in this repository:

- Executable: [evosuite-1.2.0.jar](evosuite-1.2.0.jar)
- Runtime test dependency: [evosuite-standalone-runtime-1.2.0.jar](evosuite-standalone-runtime-1.2.0.jar)

The executable jar file contains EvoSuite together with all its dependency libraries, so this is all you need to _generate tests_. Tests generated by EvoSuite use several EvoSuite-specific dependencies and types of instrumentation, mainly to avoid _flaky tests_. These dependencies need to be available on the classpath when running the generated tests. One option is to simply use the executable jar file as well for that, but if you don’t want all the test generation dependencies on the classpath you can simply use the runtime jar, which is smaller and contains fewer dependencies.

you can now execute EvoSuite for the first time:

`java -jar evosuite-1.2.0.jar`

```
* EvoSuite 1.2.0
usage: EvoSuite
 -base_dir <arg>            Working directory in which tests and reports
                            will be placed
 -class <arg>               target class for test generation. A fully
                            qualifying needs to be provided, e.g.
                            org.foo.SomeClass
 -continuous <arg>          Run Continuous Test Generation (CTG). Valid
                            values are: [EXECUTE, INFO, CLEAN]
 -criterion <arg>           target criterion for test generation. Can
                            define more than one criterion by using a ':'
                            separated list
 -D <property=value>        use value for given property
 ...
```

This output lists all the possible command-line options, as we haven’t told EvoSuite what to do yet.

To make the rest of this tutorial easier to read, we will create an environment variable to execute EvoSuite:

`alias evosuite="java -jar $(pwd)/evosuite-1.2.0.jar"`

> [!NOTE]
> WINDOWS: You can achieve the same using: `set evosuite=java -jar "%CD%"\evosuite-1.2.0.jar`

Now we can simply invoke EvoSuite by typing:

`evosuite`

> [!NOTE]
> WINDOWS: You might need `%evosuite%`

## EvoSuite on the Command Line

### Preparing the class under test

We will be testing a simple `Stack` data structure implementation. The implementation is available in the [tutorial-stack](tutorial-stack) subdirectory as a Maven project.

Now, let’s have a closer look at this example. In a terminal, navigate into this subdirectory, i.e., `cd tutorial-stack`. This is where we will be running EvoSuite.

You will find three files in here. First, there is a `pom.xml`, which is the Maven build file. Second, there is the class under test, which you can find in `src/main/java/tutorial/Stack.java`:

```java
package tutorial;

import java.util.EmptyStackException;

public class Stack<T> {
    private int capacity = 10;
    private int pointer  = 0;
    private T[] objects = (T[]) new Object[capacity];

    public void push(T o) {
        if(pointer >= capacity)
            throw new RuntimeException("Stack exceeded capacity!");
        objects[pointer++] = o;
    }

    public T pop() {
        if(pointer <= 0)
            throw new EmptyStackException();
        return objects[--pointer];
    }

    public boolean isEmpty() {
        return pointer <= 0;
    }
}
```

The third file is an existing test suite `src/test/java/tutorial/StackTest.java`, which we will look into later.

Let's start by compiling the project:

`mvn compile`

Maven will produce some output to keep you informed about what it is doing, and at the end, you should see a success message similar to the following:

```
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  0.470 s
[INFO] Finished at: 2024-05-01T21:58:28+01:00
[INFO] ------------------------------------------------------------------------
```

If you see a build failure, you will have to look at the error messages and troubleshoot to fix any errors in your setup.

As a result of the compilation, we now have a file `target/classes/tutorial/Stack.class` which contains the bytecode of the `Stack` class.

### Generating tests

Now let’s invoke EvoSuite on our example class. For this, we need to tell EvoSuite two things:

1. What is the class under test?
2. What is the classpath where it can find the bytecode of the class under test and its dependencies?

The class under test is specified using the `-class` argument (assuming we are targeting a single class). Note that we need to use the _fully qualified class name_; that is, we need to include the package name. Thus, in our example, we need to use `-class tutorial.Stack`.

The classpath is specified using the `-projectCP` argument. This takes a regular classpath entry, like you would specify when using `java -cp` or by setting `export CLASSPATH=<...>`. In our case, we compiled the `Stack.java` class using Maven, which by default places compiled classes inside the `target/classes` directory, therefore, we can now run EvoSuite as follows:

`evosuite -class tutorial.Stack -projectCP target/classes`

If everything worked correctly, then EvoSuite has now produced two files:

`evosuite-tests/tutorial/Stack_ESTest.java`
`evosuite-tests/tutorial/Stack_ESTest_scaffolding.java`

Let’s take a closer look at these two files.

If we look into the scaffolding file, we’ll see lots of things happening in methods annotated with `@Before` and `@After`. These JUnit annotations ensure that these methods are executed before/after execution of each test. The reason for all this is that EvoSuite avoids flaky tests by controlling everything that might be non-deterministic. The scaffolding ensures that tests are always executed in the same consistent state, so they should only fail if they reveal a bug, not because they are flaky. The scaffolding may look a bit scary, but the good news is that you’ll probably never need to look at it.

The JUnit tests are in the main `Stack_ESTest.java` file. The test class inherits from the scaffolding, such that all the setup/pulldown happens without showing all the overhead to ensure tests are not flaky:

```java
@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class Stack_ESTest extends Stack_ESTest_scaffolding {
```

Besides inheriting from the scaffolding class, we also see an annotation that is specific to EvoSuite. The test class declares that it will be executed with the `EvoRunner`, rather than a default JUnit runner. The test runner takes a couple of parameters that specify which parts of the execution environment are controlled. You can safely ignore these for now – the values for these parameters are set automatically by EvoSuite.

The rest of the file consists of the actual tests. By default, the tests are annotated with `@Test` and use JUnit version 4. Because automatically generated tests sometimes do silly things causing infinite loops, all tests have a specified timeout, with a default value of 4 seconds.

### Running EvoSuite tests

Let’s now compile the tests. The compiler will need several things on the classpath:

- `target/classes`: This is the directory that we need for the tutorial.Stack class
- `evosuite-standalone-runtime-1.2.0.jar`: This is the EvoSuite runtime library.
- `evosuite-tests`: This is the directory where we put the test class files
- `junit-4.12.jar` and `hamcrest-core-1.3.jar`: We need JUnit to execute JUnit tests.

In order to get the JUnit and Hamcrest dependencies, we can use Maven again. Type the following command:

`mvn dependency:copy-dependencies`

This will download the two jar files and put them into the directory `target/dependency`. The output should look like this:

```
[INFO] Copying junit-4.12.jar to [...]/evosuite-demo/tutorial-stack/target/dependency/junit-4.12.jar
[INFO] Copying hamcrest-core-1.3.jar to [...]/evosuite-demo/tutorial-stack/target/dependency/hamcrest-core-1.3.jar
```

Now we need to tell the Java compiler where to find all these things, for which we set the `CLASSPATH` environment variable:

`export CLASSPATH="target/classes:../evosuite-standalone-runtime-1.2.0.jar:evosuite-tests:target/dependency/junit-4.12.jar:target/dependency/hamcrest-core-1.3.jar"`

> [!NOTE]
> WINDOWS: The path separator on Windows is the semicolon ; while on Unix-like systems it’s the colon :. Although not usually necessary, you may need to use the backslash \ as directory separator. The Windows equivalent of the command above should be: `set CLASSPATH=target/classes:evosuite-standalone-runtime-1.2.0.jar;evosuite-tests;target/dependency/junit-4.12.jar;target/dependency/hamcrest-core-1.3.jar`

For now, we will simply compile the tests in place. Type the following command:

`javac evosuite-tests/tutorial/*.java`

Check that there are the two .class files in `evosuite-tests/tutorial`. If they are not there, then check what error messages the Java compiler gave you – most likely some part of the classpath is not set correctly and you need to troubleshoot.

If they were compiled correctly, we can now run the tests on the command line:

`java org.junit.runner.JUnitCore tutorial.Stack_ESTest`

If you followed all the steps so far correctly, you should see the following output:

```
JUnit version 4.12
.....
Time: 0.562

OK (6 tests)
```

Congratulations! You have just generated and executed your first EvoSuite test suite!

### Playing with EvoSuite settings

Now let’s have a closer look at how we can influence what EvoSuite does. First, we had to wait quite a while until test generation was completed – even though this is such a simple class. A simple way to tell EvoSuite that we’ve waited long enough for test generation is to simply hit Ctrl+C while it is generating tests. EvoSuite will stop the search, and write the test cases generated up to that point. If you hit Ctrl+C a second time, this will kill EvoSuite completely.

To try this out, generate some more tests:

`evosuite -class tutorial.Stack -projectCP target/classes`

After a couple of seconds, when you think coverage is sufficient (you will see a progress bar e.g., `[Cov:================================>  92%]`), hit Ctrl+C and wait for the tests to be written. If you wait 5-10 seconds, you will notice that the tests we got still cover all the lines in the Stack class. So why does EvoSuite take so long? The reason is that EvoSuite by default targets not only lines of code, but attempts to satisfy a range of different testing criteria, including things like mutation testing (see the output evosuite produces to see exactly which criteria are being targetted). Some of the testing goals described by these criteria are infeasible, which means that there exist no tests that can satisfy them; some other goals are just so difficult to cover that EvoSuite cannot easily produce the tests. This is a well-known aspect of test generation, and to deal with it, EvoSuite uses a fixed amount of time for test generation, and stops generating tests once this time has been used up. By default, this is 60 seconds. If we want to change this, then besides manually stopping EvoSuite, we have two options: changing the testing criteria to avoid the stronger criteria that may not be satisfiable, or setting a more generous timeout explicitly.

Let’s start by generating tests for a weaker criterion. We’ll use branch coverage, which requires that all if-conditions evaluate to true and false, and all lines of code are covered. We can set the criterion using the -criterion argument. To generate branch coverage tests, type:

`evosuite -class tutorial.Stack -projectCP target/classes -criterion branch`

EvoSuite will work for a couple of seconds, but once it has reached 100% branch coverage it will terminate and give us a branch coverage test suite.

Alternatively, we can tell EvoSuite how much time to spend on test generation. EvoSuite uses search-based techniques, so the time it spends on test generation is called the search budget. Unlike the target criterion, the search budget is not a command line argument, but one of many properties that configure how EvoSuite behaves. To set properties, we can use the `-Dproperty=value` command line argument. For example, to specify the search budget to 20 seconds, we would use the following command:

`evosuite -class tutorial.Stack -projectCP target/classes -Dsearch_budget=20`

EvoSuite has a large number of parameters that can all be set using the `-Dproperty=value` syntax. To get an overview of the available properties, type the following command:

`evosuite -listParameters`

For example, by default EvoSuite will apply minimisation to test cases, which means that it removes all statements that are not strictly needed to satisfy the coverage goals; this can be deactivated using `-Dminimize=false`. EvoSuite also minimises the assertions it adds, and this can be changed by switching the assertion generation strategy, e.g. to `-Dassertion_strategy=all`. Thus, to generate long tests with loads of assertions we could use the following command:

`evosuite -class tutorial.Stack -projectCP target/classes -Dsearch_budget=20 -Dminimize=false -Dassertion_strategy=all -Dtest_dir=evosuite-tests-longer`

Notice that we are setting an additional property `-Dtest_dir=evosuite-tests-longer` to tell EvoSuite to place the resulting tests in a different folder instead of the default `evosuite-tests`. You can now compare the two resulting test suites, either by opening in your favourite editor side by side, or by running:

`diff evosuite-tests/tutorial/Stack_ESTest.java evosuite-tests-longer/tutorial/Stack_ESTest.java`

The effect of the properties we have set should be fairly noticeable, i.e., the tests in `evosuite-tests-longer` should be longer and contain more assertions.

At this point, take some time to explore the many parameters EvoSuite has, and play with some of them. For example, consider using the `test_naming_strategy` property to ask EvoSuite to generate tests with more descriptive test names in a different directory, e.g., `evosuite-tests-naming`, and compare the resulting test suite against the first test suite you generated. Can you notice the difference?

### Remembering EvoSuite settings

It quickly becomes inconvenient to provide the project classpath to EvoSuite every time we run it on the same project, in particular when projects become more complex and the number of classpath entries is large. Similarly, one might want to set certain properties for all runs of EvoSuite. We can set these things in a properties file, which EvoSuite by default tries to find in `evosuite-files/evosuite.properties`. We can generate this file automatically using the `-setup` command. Let’s tell EvoSuite that our classes are found in the classpath entry `src`:

`evosuite -setup target/classes`

EvoSuite creates a new directory `evosuite-files` containing `evosuite.properties`. In this properties file, all properties are listed with their default values. Notice that all of these properties are _commented out_, so if you want to change any of them, you need to find them in the file, uncomment them, and change their values. From now on, EvoSuite will pick up this configuration file whenever running on this project. Thus, we don’t need to provide the project classpath and can simply call:

`evosuite -class tutorial.Stack`

Give this ago by setting the properties we used in the previous section in the `evosuite.properties` file, running EvoSuite again and observing the results.

### Working with existing tests

We mentioned earlier that there is a third file in our little Maven project, but so far we have ignored it. The third file `src/test/java/tutorial/StackTest.java` is a test suite containing a single test:

```java
package tutorial;

import org.junit.Test;
import org.junit.Assert;

public class StackTest {

    @Test
    public void test() {
        Stack<Object> stack = new Stack<Object>();
        stack.push(new Object());
        Assert.assertFalse(stack.isEmpty());
    }
}
```

Not a very exciting test, and also one that EvoSuite can easily generate. However, in practice, you might have already written some tests at the point you invoke EvoSuite, and so maybe you don’t want to see some generated tests for code you have already covered.

We can tell EvoSuite to only output tests that are not already covered using the `junit` property. For example, to tell EvoSuite to only give us tests that are not already covered by `tutorial.StackTest`, we would set the property using `-Djunit=tutorial.StackTest`. If we have multiple test classes, we can use a colon-separated list for the property.

We also need to tell EvoSuite where to find this test, as it needs to execute the test. So let’s first make sure that the test is compiled and passes. To do this, let’s use Maven. Type the following command:

`mvn test`

This should give you the following output (among some other messages):

```
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running tutorial.StackTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.027 s -- in tutorial.StackTest
[INFO]
[INFO] Results:
[INFO]
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
```

If the test doesn’t pass then most likely you have edited (and broken?) the Stack class and should fix it.

For EvoSuite, the interesting part is that Maven placed the bytecode of this test into the directory `target/test-classes/tutorial/StackTest.class`. If we want to know how great this test suite is, we can ask EvoSuite to measure the coverage for us. EvoSuite supports the command `-measureCoverage`, and we need to specify the class under test (`-class tutorial.Stack`), the tests we are interested in (`-Djunit=tutorial.StackTest`), the classpath containing the class under test and the tests (`-projectCP target/classes:target/test-classes`), and optionally, which criteria we are interested (e.g., `-criterion branch`):

`evosuite -measureCoverage -class tutorial.Stack -Djunit=tutorial.StackTest -criterion branch -projectCP target/classes:target/test-classes`

This should give you the following output (among other messages):

```
* Executed 1 unit test(s)
* Target class tutorial.Stack
* Coverage of criterion BRANCH: 43%
* Number of covered goals: 3 / 7
* Total number of covered goals: 3 / 7
* Total coverage: 43%
```

If we now only want to have tests that cover the remaining 4 branch coverage goals, we would invoke EvoSuite as follows:

`evosuite -class tutorial.Stack -Djunit=tutorial.StackTest -projectCP target/classes:target/test-classes -criterion branch`

> [!NOTE]
> WINDOWS: Remember to use the semicolon path separator (;) instead of colon (:) when running this command on Windows.

Take a look at `evosuite-tests/tutorial/Stack_ESTest.java` to check that it worked.

### Running EvoSuite on multiple classes

Our example project only has a single class, so all calls to EvoSuite so far used the argument `-class`. However, sometimes we might want to target more than just a single class, for example when generating a regression test suite. In this case, we can replace the `-class` argument with either `-prefix` or `-target`.

The `-target` argument specifies a classpath entry (e.g., directory or jar file). EvoSuite will then be invoked sequentially on every testable class it can find in that classpath entry. If you want to know which classes EvoSuite thinks are testable (e.g., public), then type the following command:

`evosuite -listClasses -target target/classes`

The output should be just our example class:

`tutorial.Stack`

To invoke EvoSuite on all the classes in a classpath entry, type the following:

`evosuite -target target/classes`

EvoSuite will now go and test each class it can find, one at a time. Alternatively, we might want to test all classes in a certain package. To test all classes in the `tutorial` package, type the following command:

`evosuite -prefix tutorial`

As our project has only one class, these runs would only just test the Stack class. Go ahead and add a new simple class inside the `tutorial` package and test out the `-prefix` and `-target` parameters by yourself.

The arguments `-target` and `-prefix` will run EvoSuite sequentially on each class they find.

## Further Pointers

In this tutorial, we have used EvoSuite from the command line and explored some of its main features and parameters. Below you can find pointers on how you could explore more advanced and/or modern options.

### JUnit 4 is so old!

EvoSuite can also generate tests in JUnit 5 (Jupiter) format. Can you find out what parameters would make EvoSuite do this?

### Just random

Research has shown that for most code, random testing is just really good already. [Randoop](https://randoop.github.io/randoop/) is a great feedback-directed random testing tool that also produces executable JUnit tests. Give it a go.

### I want tests in my IDE directly

There are several [experimental plugins](https://www.evosuite.org/downloads/) for EvoSuite. Give them a try at your own responsibility, we can't guarantee they will work well.

Fortunately, the latest news is that the brand-new [TestSpark](https://plugins.jetbrains.com/plugin/21024-testspark) IntelliJ IDEA has been released, which integrates LLMs and EvoSuite for test generation. This should be a game-changer!

### Python

EvoSuite is great, but I work mostly on Python, is there any search-based test generation tool I can look into? Yes, a similar tool to EvoSuite has been developed for Python: [Pynguin](https://pynguin.readthedocs.io/en/latest/index.html).